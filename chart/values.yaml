image:
  repository: reg.domain.com/app/tcpdump-book
  tag: d58a4b4
  pullPolicy: IfNotPresent

  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  pullSecrets:
    - dockerhub

Namespace: tcpdump-book

ingress:
  enabled: true
  annotations:
    kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: tcpdump-gitbook.domain.com
      paths:
        - /
  tls:
  - secretName: wildcard-tls
    hosts:
      - tcpdump-gitbook.domain.com

## Affinity for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app
          operator: In
          values:
          - tcpdump-book
      topologyKey: "kubernetes.io/hostname"

## StatefulSet annotations
annotations: {}

config:
  http_listen_port: 80
  bookConfig:
    nginx.conf: |-
      worker_processes auto;
      
      events {
          worker_connections 8000;
          multi_accept on;
      }
      
      
      http {
          include       /etc/nginx/mime.types;
          default_type  application/octet-stream;
      
          log_format compression '$remote_addr - $remote_user [$time_local] '
              '"$request" $status $upstream_addr '
              '"$http_referer" "$http_user_agent"';
      
          server {
              listen 80;
              underscores_in_headers on;
              access_log /var/log/nginx/access.log compression;
      
              root /var/www;
              
              index index.html index.htm;
      
              location / {
                  try_files $uri $uri/ /index.html;
              }
      
              location /healthz {
                  if ($http_x_custom_header = "healthz"){ 
                      return 200 "healthz";
                  }
                  return 403; 
              }
      
              location ~ ^.+\..+$ {
                  try_files $uri =404;
              }
          }
      }
#  ruler:
#    storage:
#      type: local
#      local:
#        directory: /rules
#    rule_path: /tmp/scratch
#    alertmanager_url: http://alertmanager.svc.namespace:9093
#    ring:
#      kvstore:
#        store: inmemory
#    enable_api: true

## Additional Loki container arguments, e.g. log level (debug, info, warn, error)
extraArgs: {}
  # log.level: debug

livenessProbe:
  httpGet:
    path: /healthz
    port: http-metrics
    httpHeaders:
    - name: X-Custom-Header
      value: healthz
  initialDelaySeconds: 5
  periodSeconds: 3

## ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy:
  enabled: false

client: {}
  # name:

## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
nodeSelector: {}

## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
## If you set enabled as "True", you need :
## - keep storageClassName same with below setting
persistence:
  enabled: false
  accessModes:
  - ReadWriteOnce
  size: 10Gi
  annotations: {}
  # selector:
  #   matchLabels:
  #     app.kubernetes.io/name: 
  # subPath: ""
  # existingClaim:

## Pod Labels
podLabels: {}

## Pod Annotations
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "http-metrics"

## Assign a PriorityClassName to pods if set
# priorityClassName:

rbac:
  create: false
  pspEnabled: false

readinessProbe:
  httpGet:
    path: /healthz
    port: http-metrics
    httpHeaders:
    - name: X-Custom-Header
      value: healthz
  initialDelaySeconds: 5
  timeoutSeconds: 1

replicas: 2

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

lifecycle:
  preStop:
    exec:
      command: ["/bin/bash", "-c", "sleep 10"]

securityContext: {}
  # fsGroup: 10001
  # runAsGroup: 10001
  # runAsNonRoot: true
  # runAsUser: 10001

service:
  type: ClusterIP
  nodePort:
  port: 80
  annotations: {}
  labels: {}
  targetPort: http-metrics

serviceAccount:
  create: true
  name:
  annotations: {}

terminationGracePeriodSeconds: 4800

## Tolerations for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
tolerations: []

# The values to set in the PodDisruptionBudget spec
# If not set then a PodDisruptionBudget will not be created
podDisruptionBudget:
# minAvailable: 1
  maxUnavailable: 1

strategy:
  rollingUpdate:
    maxSurge: 25%
    maxUnavailable: 25%
  type: RollingUpdate

serviceMonitor:
  enabled: false
  interval: ""
  additionalLabels: {}
  annotations: {}
  # scrapeTimeout: 10s

initContainers: []
# - name: my-init-container
#   image: busybox:latest
#   command: ['sh', '-c', 'echo hello']

extraContainers: []
# - name: reverse-proxy
#   image: angelbarrera92/basic-auth-reverse-proxy:dev
#   args:
#     - "serve"
#     - "--upstream=http://localhost:3100"
#     - "--auth-config=/etc/reverse-proxy-conf/authn.yaml"
#   ports:
#     - name: http
#       containerPort: 11811
#       protocol: TCP
#   volumeMounts:
#     - name: reverse-proxy-auth-config
#       mountPath: /etc/reverse-proxy-conf


extraVolumes:
  - name: config
    configMap:
      name: tcpdump-book-config

extraVolumeMounts: 
  - mountPath: /etc/nginx/nginx.conf
    name: config
    subPath: nginx.conf

extraPorts: []
# - port: 11811
#   protocol: TCP
#   name: http
#   targetPort: http

env: []

# When specified, you also need to add a ruler config section above. An example is shown in the alerting docs.
alerting_groups: []
#  - name: example
#    rules:
#    - alert: HighThroughputLogStreams
#      expr: sum by(container) (rate({job=~"dev/.*"}[1m])) > 1000
#      for: 2m
